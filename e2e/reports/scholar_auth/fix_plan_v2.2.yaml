metadata:
  app: scholar_auth
  version: v2.2
  owner: Auth Infrastructure Team
  target_score: 4
  current_score: 1
  gate_deadline: T+24h Infrastructure Gate
  last_updated: 2025-10-29T19:42:00Z

tasks:
  - id: FP-AUTH-001
    title: Fix JWKS endpoint 500 error
    severity: P0
    eta_hours: 4
    acceptance_criteria:
      - GET /.well-known/jwks.json returns 200 OK
      - Content-Type is application/json
      - Response contains valid JSON with "keys" array
      - At least one JWK present with fields (kid, kty, use, n, e) for RS256
      - P95 TTFB ≤ 120ms across 3 samples
      - No 5xx errors across 10 consecutive requests
    implementation_notes: |
      Root cause hypothesis: JWKS generation failing due to missing/corrupted signing key or file I/O error.
      
      Steps:
      1. Check server logs for JWKS endpoint errors (grep "JWKS" or "jwks.json" in logs)
      2. Verify RSA key pair exists in secrets/filesystem:
         - Check for JWT_PRIVATE_KEY or similar env var
         - Verify key file permissions and validity
      3. If keys missing, generate new RSA key pair:
         ```bash
         # Generate RSA 2048-bit key pair
         openssl genrsa -out private.pem 2048
         openssl rsa -in private.pem -pubout -out public.pem
         
         # Convert to JWK format (use jose or node-jose library)
         npm install -g node-jose
         jose-util convert -t pkcs1-pem private.pem -o jwks.json
         ```
      4. Update JWKS endpoint handler to serve static or dynamically generated JWKS:
         ```javascript
         // Option A: Static JWKS (fastest)
         router.get('/.well-known/jwks.json', (req, res) => {
           res.setHeader('Content-Type', 'application/json');
           res.setHeader('Cache-Control', 'public, max-age=3600');
           res.status(200).json({
             keys: [
               {
                 kid: "sig-2025-10-29",
                 kty: "RSA",
                 use: "sig",
                 alg: "RS256",
                 n: "<modulus_base64url>",
                 e: "AQAB"
               }
             ]
           });
         });
         
         // Option B: Dynamic from env/secret
         const { exportJWK } = require('jose');
         router.get('/.well-known/jwks.json', async (req, res) => {
           try {
             const publicKey = crypto.createPublicKey(process.env.JWT_PUBLIC_KEY);
             const jwk = await exportJWK(publicKey);
             jwk.kid = "sig-2025-10-29";
             jwk.use = "sig";
             jwk.alg = "RS256";
             res.setHeader('Content-Type', 'application/json');
             res.setHeader('Cache-Control', 'public, max-age=3600');
             res.status(200).json({ keys: [jwk] });
           } catch (err) {
             console.error('JWKS generation failed:', err);
             res.status(500).json({ error: 'server_error', message: 'JWKS generation failed' });
           }
         });
         ```
      5. Test endpoint locally:
         ```bash
         curl -s http://localhost:PORT/.well-known/jwks.json | jq .
         # Verify: {"keys":[{...}]}
         ```
      6. Deploy and verify in production with 3 samples
    risk: high
    rollback: |
      If fix breaks token verification:
      1. Revert to previous git commit
      2. Restore previous JWKS from backup
      3. Clear any cached JWKs at relying parties (may require cache TTL expiry)
    notes: |
      CRITICAL: Ensure kid (Key ID) in JWKS matches kid in JWT headers.
      CRITICAL: Cache JWKS responses (max-age=3600) to reduce load.
      SECURITY: Never expose private keys in JWKS; only public keys (n, e).
      
      Fast fix (if urgent): Serve static JWKS file from /public/.well-known/jwks.json

  - id: FP-AUTH-002
    title: Add missing security headers (5/6 absent)
    severity: P0
    eta_hours: 2
    acceptance_criteria:
      - Content-Security-Policy header present with strict policy
      - X-Content-Type-Options header set to "nosniff"
      - X-Frame-Options header set to "DENY" or "SAMEORIGIN"
      - Referrer-Policy header set to "no-referrer" or "strict-origin-when-cross-origin"
      - Permissions-Policy header present (even if empty)
      - All headers present on /.well-known/openid-configuration, /health, and root
    implementation_notes: |
      Add security middleware to Express/Fastify app:
      
      ```javascript
      // Install helmet (if not present)
      // npm install helmet
      
      const helmet = require('helmet');
      
      app.use(helmet({
        contentSecurityPolicy: {
          directives: {
            defaultSrc: ["'self'"],
            scriptSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'"],
            imgSrc: ["'self'", "data:", "https:"],
            connectSrc: ["'self'"],
            fontSrc: ["'self'"],
            objectSrc: ["'none'"],
            mediaSrc: ["'none'"],
            frameSrc: ["'none'"],
          },
        },
        hsts: {
          maxAge: 63072000, // 2 years (already present)
          includeSubDomains: true,
        },
        frameguard: {
          action: 'deny', // X-Frame-Options: DENY
        },
        noSniff: true, // X-Content-Type-Options: nosniff
        referrerPolicy: {
          policy: 'no-referrer',
        },
        permissionsPolicy: {
          features: {
            camera: ["'none'"],
            microphone: ["'none'"],
            geolocation: ["'none'"],
          },
        },
      }));
      
      // Alternative: Manual headers
      app.use((req, res, next) => {
        res.setHeader('Content-Security-Policy', "default-src 'self'; script-src 'self'; object-src 'none';");
        res.setHeader('X-Content-Type-Options', 'nosniff');
        res.setHeader('X-Frame-Options', 'DENY');
        res.setHeader('Referrer-Policy', 'no-referrer');
        res.setHeader('Permissions-Policy', 'camera=(), microphone=(), geolocation=()');
        next();
      });
      ```
      
      Steps:
      1. Add helmet package or custom middleware early in middleware chain
      2. Configure CSP to allow OIDC flows (may need 'unsafe-inline' for some login UIs)
      3. Test that /.well-known endpoints still return JSON (not blocked by CSP)
      4. Verify headers with: curl -I https://scholar-auth-jamarrlmayes.replit.app/health
    risk: medium
    rollback: |
      If CSP blocks legitimate auth flows:
      1. Temporarily set Content-Security-Policy-Report-Only instead of enforcing
      2. Monitor CSP violation reports
      3. Adjust directives incrementally
    notes: |
      CSP for auth services should be strict but allow OIDC redirects.
      X-Frame-Options: DENY is critical to prevent clickjacking on login pages.
      
      Quick win: Add all 5 headers with basic values; refine CSP policy in P1.

  - id: FP-AUTH-003
    title: Implement JWKS caching and rotation window documentation
    severity: P1
    eta_hours: 3
    acceptance_criteria:
      - JWKS response includes Cache-Control header with max-age=3600 or higher
      - Key rotation policy documented (e.g., 90-day rotation, 7-day overlap)
      - JWKS supports multiple keys (current + previous) during rotation window
      - Relying party documentation updated with JWKS cache TTL guidance
    implementation_notes: |
      JWKS caching reduces load and improves relying party performance:
      
      ```javascript
      router.get('/.well-known/jwks.json', async (req, res) => {
        res.setHeader('Content-Type', 'application/json');
        res.setHeader('Cache-Control', 'public, max-age=3600, s-maxage=7200'); // 1h browser, 2h CDN
        
        const jwks = {
          keys: [
            { kid: 'sig-2025-10-29', kty: 'RSA', use: 'sig', alg: 'RS256', ... }, // Current
            { kid: 'sig-2025-09-29', kty: 'RSA', use: 'sig', alg: 'RS256', ... }, // Previous (rotation window)
          ]
        };
        
        res.status(200).json(jwks);
      });
      ```
      
      Document rotation policy:
      - Rotate keys every 90 days
      - Overlap window: 7 days (both old and new keys in JWKS)
      - kid format: sig-YYYY-MM-DD
      - Relying parties must respect Cache-Control and refetch on 401/403 JWT errors
    risk: low
    rollback: |
      Reduce cache TTL if key rotation needs to be expedited.
    notes: |
      Industry standard: 1-hour cache, 90-day rotation.
      Always include previous key during rotation window to avoid token invalidation.

  - id: FP-AUTH-004
    title: Add JWKS endpoint monitoring and alerting
    severity: P1
    eta_hours: 4
    acceptance_criteria:
      - Health check includes JWKS endpoint validation (internal canary)
      - Alert triggers if JWKS 5xx rate >0.1% over 5-minute window
      - P95 TTFB tracking for /.well-known/jwks.json in observability dashboard
      - Daily JWKS key expiry check (warn 30 days before rotation deadline)
    implementation_notes: |
      Add internal JWKS health check:
      
      ```javascript
      // In /health endpoint dependencies check
      async function checkJWKS() {
        try {
          const response = await fetch('https://scholar-auth-jamarrlmayes.replit.app/.well-known/jwks.json');
          if (!response.ok) {
            return { status: 'unhealthy', error: `JWKS returned ${response.status}` };
          }
          const data = await response.json();
          if (!data.keys || data.keys.length === 0) {
            return { status: 'unhealthy', error: 'JWKS has no keys' };
          }
          return { status: 'healthy', keyCount: data.keys.length };
        } catch (err) {
          return { status: 'unhealthy', error: err.message };
        }
      }
      
      app.get('/health', async (req, res) => {
        const jwksCheck = await checkJWKS();
        res.json({
          status: jwksCheck.status === 'healthy' ? 'healthy' : 'degraded',
          dependencies: {
            auth_db: { status: 'healthy', responseTime: 24 },
            jwks: jwksCheck,
          },
        });
      });
      ```
      
      Set up alerting (Datadog/Prometheus):
      - jwks_5xx_rate{app="scholar_auth"} > 0.001 for 5 minutes → PagerDuty P1
      - jwks_p95_ttfb_ms{app="scholar_auth"} > 200 for 10 minutes → Slack warning
    risk: low
    rollback: |
      Disable health check dependency if it causes cascading failures.
    notes: |
      JWKS downtime directly impacts all authentication; treat as tier-1 critical.

  - id: FP-AUTH-005
    title: Optimize P95 TTFB for JWKS endpoint
    severity: P2
    eta_hours: 2
    acceptance_criteria:
      - P95 TTFB ≤ 100ms (current 144ms, target <100ms for margin)
      - JWKS response uses gzip/brotli compression
      - Static JWKS served from memory (not filesystem I/O each request)
    implementation_notes: |
      Current P95 TTFB: 144ms (acceptable but can be optimized)
      
      Optimizations:
      1. Serve JWKS from in-memory cache (no disk I/O):
         ```javascript
         let jwksCache = null;
         
         function loadJWKS() {
           // Load once at startup
           const publicKey = crypto.createPublicKey(process.env.JWT_PUBLIC_KEY);
           const jwk = exportJWKSync(publicKey);
           jwk.kid = 'sig-2025-10-29';
           jwk.use = 'sig';
           jwk.alg = 'RS256';
           jwksCache = { keys: [jwk] };
         }
         
         loadJWKS(); // On app startup
         
         router.get('/.well-known/jwks.json', (req, res) => {
           res.setHeader('Content-Type', 'application/json');
           res.setHeader('Cache-Control', 'public, max-age=3600');
           res.status(200).json(jwksCache); // Instant response from memory
         });
         ```
      2. Enable compression middleware (if not present):
         ```javascript
         const compression = require('compression');
         app.use(compression());
         ```
      3. Consider CDN/edge caching for /.well-known/* (Cloudflare, Fastly)
    risk: low
    rollback: |
      Revert to filesystem-based JWKS if memory cache causes stale key issues.
    notes: |
      Target: <50ms P95 TTFB for JWKS (achievable with in-memory cache).

quick_wins:
  - id: QW-001
    title: Add Cache-Control to JWKS endpoint
    eta_minutes: 5
    steps:
      - Add res.setHeader('Cache-Control', 'public, max-age=3600') to JWKS handler
      - Verify with curl -I that header is present
    impact: Reduces load on JWKS endpoint by 90%+
  
  - id: QW-002
    title: Add X-Content-Type-Options header globally
    eta_minutes: 10
    steps:
      - Add app.use((req,res,next) => { res.setHeader('X-Content-Type-Options', 'nosniff'); next(); })
      - Verify with curl -I that header is present on all endpoints
    impact: Prevents MIME-sniffing attacks

  - id: QW-003
    title: Test JWKS endpoint in dev/staging before production fix
    eta_minutes: 15
    steps:
      - Curl /.well-known/jwks.json in dev environment
      - Verify keys array present and valid
      - Test JWT signature verification with sample token
    impact: De-risks production deployment

verification_steps:
  - step: 1
    action: GET /.well-known/jwks.json (3 samples)
    expected: |
      [YYYY-MM-DDTHH:MM:SSZ] GET https://scholar-auth-jamarrlmayes.replit.app/.well-known/jwks.json
      → 200, ttfb_ms≤120, content_type=application/json
      Payload: {"keys":[{"kid":"...","kty":"RSA","use":"sig","alg":"RS256","n":"...","e":"AQAB"}]}
  
  - step: 2
    action: Check security headers on /health
    expected: |
      curl -I https://scholar-auth-jamarrlmayes.replit.app/health
      HTTP/2 200
      strict-transport-security: max-age=63072000
      content-security-policy: default-src 'self'
      x-content-type-options: nosniff
      x-frame-options: DENY
      referrer-policy: no-referrer
      permissions-policy: camera=(), microphone=()
  
  - step: 3
    action: Re-run full Agent3-QA/2.2 validation
    expected: |
      Final score: ≥4/5 (target 4/5 to unblock T+24h gate)
      - JWKS endpoint: 200 OK with valid keys
      - Security headers: 6/6 present
      - P95 TTFB: ≤120ms on all critical endpoints
  
  - step: 4
    action: Verify JWT signature verification works end-to-end
    expected: |
      1. Request ID token from /oidc/token (valid auth code flow)
      2. Fetch JWKS from /.well-known/jwks.json
      3. Verify ID token signature using JWK from JWKS
      4. Decode claims successfully

notes: |
  Post-fix validation checklist:
  - All 3 critical endpoints (OIDC config, JWKS, health) return 200
  - JWKS contains valid RSA JWK with kid, n, e fields
  - Security headers present on all endpoints
  - P95 TTFB ≤120ms
  - No 5xx errors in 100-request load test
  
  If score reaches 4/5: T+24h Infrastructure Gate UNBLOCKED
  If score reaches 5/5: Excellent; auth service production-ready
  
  ETA to 4/5: 6 hours (FP-AUTH-001 + FP-AUTH-002 completed)
  ETA to 5/5: 15 hours (all P0/P1 tasks completed)
